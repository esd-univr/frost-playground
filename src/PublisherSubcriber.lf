target Python{
    fast: True,
    files: [
        "../frost/src/python_lib/frost.py",
        "../frost/src/python_lib/l_formatter.py",
        "../frost/src/python_lib/time_utils.py"
    ],
    logging: error,
    single-threaded: false,
}

import FrostDataModel from "../frost/src/lib/FrostDataModel.lf"

preamble{=
    import uuid
    from frost import *
=}

reactor Publisher extends FrostDataModel{
    state words = ["Hello", "world", "this", "is", "a", "test", "message"]
    state word_node

    reaction(startup) -> channel_out{=
        self.word_node = self.data_model.get_node("root/word")
    =}

    timer publish_timer(1 sec, 2 sec)

    reaction(publish_timer){=
        if not self.words:
            lf.request_stop()
            return 0
        
        word = self.words.pop(0)
        self.word_node.value = word
        self.logger.info(f"{self.name} updated word node to: {self.word_node._subscriptions}")
        self.logger.info(f"{self.name} publishing word: {word}")
    =}
}

reactor Subscriber extends FrostDataModel{    
    state sentence

    reaction(startup) -> channel_out{=
        self.sentence = self.data_model.get_node("root/sentence")
        self.logger.info(f"{self.name} subscribed to the topic 'word'")
        message = FrostMessage(
            sender = self.name,
            target = "publisher",
            identifier = str(uuid.uuid4()),
            header = FrostHeader(
                type = MsgType.REQUEST,
                version = (1,0,0),
                namespace = MsgNamespace.VARIABLE,
                msg_name = VariableMsgName.SUBSCRIBE,
            ),
            payload = VariablePayload(node = "root/word"),
        )
        self.logger.info(f"{self.name} sent a subscribe message: {message}")
        self._set_output_port(message, channel_out)
    =}

    reaction(shutdown){=
        self.logger.warning(self.sentence.value)
    =}

    reaction(message_filter.responses){=
        message = message_filter.responses.value[0][1]
        self.logger.info(f"Subscriber {self.name} received a message: {message}")
        if message.header.namespace == MsgNamespace.VARIABLE and message.header.msg_name == VariableMsgName.UPDATE:
            self.sentence.value += " " + message.payload.value
    =}

}

main reactor{
    publisher = new Publisher(name = "publisher")
    subscriber = new Subscriber(name = "subscriber")

    publisher.channel_out -> subscriber.channel_in after 100 msec
    subscriber.channel_out -> publisher.channel_in after 100 msec
}