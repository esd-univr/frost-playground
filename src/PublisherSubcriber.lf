target Python{
    fast: True,
    files: [
        "../frost/src/python_lib/frost.py",
        "../frost/src/python_lib/l_formatter.py",
        "../frost/src/python_lib/time_utils.py"
    ],
    logging: error,
    single-threaded: false,
}

import FrostDataModel from "../frost/src/lib/FrostDataModel.lf"

preamble{=
    import uuid
    import yaml
    import math 
    import os 
    import logging
    from enum import Enum
    from frost import FROST_CONFIG, is_target_valid
    from machine_data_model.protocols.frost_v1.frost_message import FrostMessage
    from machine_data_model.protocols.frost_v1.frost_header import MsgType, MsgNamespace, ProtocolMsgName, FrostHeader, MethodMsgName, VariableMsgName
    from machine_data_model.protocols.frost_v1.frost_payload import VariablePayload, ProtocolPayload, MethodPayload, ErrorPayload
    from machine_data_model.protocols.frost_v1.frost_protocol_mng import FrostProtocolMng
    from machine_data_model.builder.data_model_builder import DataModelBuilder
    from machine_data_model.protocols.frost_v1.frost_message_builder import FrostMessageBuilder
    from machine_data_model.protocols.protocol_mng import Message
    from machine_data_model.nodes.method_node import MethodNode, AsyncMethodNode
    from machine_data_model.nodes.composite_method.composite_method_node import CompositeMethodNode
    from machine_data_model.nodes.variable_node import NumericalVariableNode, StringVariableNode, BooleanVariableNode, ObjectVariableNode
    from machine_data_model.nodes.folder_node import FolderNode
=}

reactor Publisher extends FrostDataModel{
    state builder = {=FrostMessageBuilder()=}
    state words = ["Hello", "world", "this", "is", "a", "test", "message"]
    state word_node

    reaction(startup) -> channel_out{=
        self.word_node = self.data_model.get_node("root/word")
    =}

    timer publish_timer(1 sec, 2 sec)

    reaction(publish_timer){=
        if not self.words:
            lf.request_stop()
            return 0
        
        word = self.words.pop(0)
        self.word_node.value = word
        self.logger.info(f"{self.name} updated word node to: {self.word_node._subscriptions}")
        self.logger.info(f"{self.name} publishing word: {word}")
    =}
}

reactor Subscriber extends FrostDataModel{    
    state builder = {=FrostMessageBuilder()=}
    state sentence

    reaction(startup) -> channel_out{=
        self.sentence = self.data_model.get_node("root/sentence")
        self.logger.info(f"{self.name} subscribed to the topic 'word'")
        message = self.builder.with_sender(self.name).with_target(
            "publisher"
        ).with_variable_subscribe_request_header().with_subscription_payload(
            node="root/word"
        ).build()
        self.logger.info(f"{self.name} sent a subscribe message: {message}")
        self._set_output_port(message, channel_out)
    =}

    reaction(shutdown){=
        self.logger.warning(self.sentence.value)
    =}

    reaction(message_filter.responses){=
        message = message_filter.responses.value[0][1]
        self.logger.info(f"Subscriber {self.name} received a message: {message}")
        if message.header.namespace == MsgNamespace.VARIABLE and message.header.msg_name == VariableMsgName.UPDATE:
            self.sentence.value += " " + message.payload.value
    =}

}

main reactor{


    publisher = new Publisher(name = "publisher")
    subscriber = new Subscriber(name = "subscriber")

    publisher.channel_out -> subscriber.channel_in after 100 msec
    subscriber.channel_out -> publisher.channel_in after 100 msec
}