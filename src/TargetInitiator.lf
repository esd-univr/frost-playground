target Python{
    fast: True,
    timeout: 10s,
    logging: error,
    single-threaded: false,
}

import FrostBus from "../frost/src/lib/FrostBus.lf"
import FrostMachine from "../frost/src/lib/FrostMachine.lf"
import FrostBase from "../frost/src/lib/FrostBase.lf"

preamble{= 
    import uuid
    from frost import *
=}

reactor Initiator extends FrostBase{
    '''
    A simple reactor that represents an initiator in the Frost protocol.
    The initiator sends a message to the target invoking a method "answer" with a string
    argument. The initiator waits for the response from the target and prints it.
    '''


    input channel_in
    output channel_out

    reaction(startup) -> channel_out{=
        self.logger.info(f"Initiator {self.name} started")
        message = FrostMessage(
            sender=self.name,
            target="frost_bus",
            identifier=str(uuid.uuid4()),
            header=FrostHeader(
                type=MsgType.REQUEST,
                version=(1, 0, 0),
                namespace=MsgNamespace.PROTOCOL,
                msg_name=ProtocolMsgName.REGISTER,
            ),
            payload=ProtocolPayload(),
        )
        self.logger.info(f"Initiator {self.name} sent a message: {message}")
        channel_out.set([message])
    =}

    input start
    reaction(start) -> channel_out{=
        self.logger.info(f"User {self.name} start signal received: {start.value}")
        if start.value:
            message = FrostMessage(
                sender=self.name,
                target="target",
                identifier=str(uuid.uuid4()),
                header=FrostHeader(
                    type=MsgType.REQUEST,
                    version=(1, 0, 0),
                    namespace=MsgNamespace.METHOD,
                    msg_name=MethodMsgName.INVOKE,
                ),
                payload=MethodPayload(
                    node="Methods/answer",
                    args=["What is your name?"],
                    kwargs={},
                ),
            )
            self.logger.info(f"{self.name}: {message.payload.args[0]}")
            self._set_channel_out_port(message, channel_out)
    =}

    reaction(channel_in) -> channel_out{=
        self.logger.info(f"Initiator {self.name} received a message: {channel_in.value}")
        message = channel_in.value[0]
        if message.header.type == MsgType.RESPONSE and message.header.namespace == MsgNamespace.METHOD:
            self.logger.info(f"{message.sender}: {message.payload.ret["response"]}")
    =}

}

reactor Target extends FrostMachine{
    '''
    A simple reactor that represents a target in the Frost protocol.
    The target receives a message from the initiator invoking a method "answer" with a string
    argument. The target executes the method and returns a string as a response.
    '''
    input start
    state method_node
    state target_name = "Bob"
    reaction(startup){=
        method_node = self.data_model.get_node("Methods/answer")
        method_node.callback = self.answer
    =}

    method answer(message){=
        self.logger.info(f"{self.name} received a message: {message}")
        if message == None or message == "":
            raise Exception("Input message is None or empty")
        return self.target_name
    =}

}

main reactor{
    '''
    This examples shows a Initiator and a Target that communicate using the Frost protocol.
    The Initiator sends a message to the Target invoking a method "answer" with a string argument.
    The Target receives the message, executes the method and returns a string as a response.
    '''
    preamble{=
        #Import local library
    =}

    bus = new FrostBus(name="frost_bus", width = 2)
    Target = new Target(name="target")
    Initiator = new Initiator(name="initiator")

    Target.channel_out, Initiator.channel_out -> bus.channel_in after 0 sec
    bus.channel_out -> Target.channel_in, Initiator.channel_in after 0 sec

    logical action delay

    reaction(delay) -> Initiator.start{=
        Initiator.start.set([True])
    =}

    reaction(startup)-> delay{=
        delay.schedule(SEC(1))
    =}
}